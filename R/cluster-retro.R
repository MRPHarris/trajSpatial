# Functions used for retrospective clustering

#' Retrospectively assign new trajectories to existing clusters.
#'
#' @description Determine which cluster/s a set of trajectories are most similar to. Uses
#'    geosphere::geoDist to determine the cluster with the least total distance between
#'    trajectory and cluster endpoints at the specified time interval. A data frame
#'    of the trajectories (filenames) and their corresponding cluster is returned.
#'    Originally written to allow for clustering in cases where the size of a trajectory dataset
#'    exceeds the ability of the HYSPLIT program to cluster it. In such a case, a representative
#'    portion of a trajectory dataset (the vast majority, ideally) can be clustered and then the
#'    rest can be retrospectively added.
#'
#' @param trajectory_filenames a vector of filenames for trajectories.
#' @param clusmean a clusmean file. Can be either a tdump file from HYSPLIT or an 'analogue' generated by trajSpatial. Returned from `create_clusmeans_analogue()`.
#' @param time_interval_hrs the time interval used to select endpoints for comparison, where 1 = all endpoints and 12 = endpoints every 12 hours.
#' @param verbose TRUE/FALSE to show progress as calculation proceeds.
#'
#' @importFrom utils txtProgressBar
#' @importFrom magrittr %>%
#' @importFrom dplyr select
#' @importFrom geosphere distGeo
#' @importFrom dplyr mutate
#'
#' @export
#'
retro_cluster <- function(trajectory_filenames,
                          clusmean,
                          time_interval_hrs = 12,
                          verbose = TRUE){
  if(verbose){
    pb = txtProgressBar(min = 0, max = length(trajectory_filenames), initial = 0, style = 3)
  }
  ## Iterate through trajectories
  tc_list <- vector('list', length(trajectory_filenames))
  for(t in seq_along(tc_list)){
    ## Read in the current trajectory
    traj_it <- read_endpoint_file(trajectory_filenames[t])
    ## Trim if required
    if(!is.null(time_interval_hrs)){
      traj_it <- traj_it[which(abs(traj_it$hour.inc) %% time_interval_hrs == 0),]
    }
    ## Now iterate through clusters, finding which is best.
    clist <- vector('list',length = length(unique(clusmean$cluster))) %>%
      'names<-'(c(seq(1,length(unique(clusmean$cluster)))))
    for(c in seq_along(clist)){
      clus_it <- clusmean %>% filter(cluster == c)
      if(!is.null(time_interval_hrs)){
        clus_it <- clus_it[which(abs(clus_it$hour.inc) %% time_interval_hrs == 0),]
      }
      ## Calculate geo distance using geosphere.
      geodist <- distGeo(p1 = as.matrix(traj_it %>% select(lon,lat)),
                         p2 = as.matrix(clus_it %>% select(lon,lat)))
      clist[[c]] <- sum(geodist)
    }
    ## Store cluster with the smallest distance diff to trajectory
    spatvar = unlist(clist) %>% as.numeric()
    tc_list[[t]] <- which(unlist(clist) == min(spatvar))
    if(verbose){setTxtProgressBar(pb,t)}
  }
  if(verbose){close(pb)}
  output_df <- trajectory_filenames %>%
    as.data.frame() %>% 'colnames<-'(c('trajectory')) %>%
    mutate(cluster = unlist(tc_list))
  output_df
}

#' Update a cluslist with new trajectories
#'
#' @description Append trajectories to an existing cluslist.
#'
#' @param cluslist A cluslist object.
#' @param retro_clustered Result returned from `retro_cluster()`.
#'
#' @importFrom rlist list.rbind
#' @importFrom magrittr %>%
#' @importFrom dplyr mutate
#' @importFrom dplyr group_by
#' @importFrom dplyr ungroup
#' @importFrom dplyr n
#'
#' @export
#'
update_cluslist <- function(cluslist,
                            retro_clustered){
  ## New file counts
  seqt <- seq(max(cluslist$V7)+1, max(cluslist$V7) + nrow(retro_clustered), 1)
  traj_list <- vector('list', nrow(retro_clustered))
  for(t in seq_along(traj_list)){
    ## Get run time info from filename
    date_dat <- lapply(strsplit(retro_clustered$trajectory[t],"[-]"),"[",c(6,7,8,9)) %>%
      unlist()
    ## Have to construct the row for this trajectory. See: https://www.ready.noaa.gov/documents/Tutorial/images/clus005.png
    trajdat <- c(retro_clustered$cluster[t],NA,date_dat,seqt[t],retro_clustered$trajectory[t])
    traj_list[[t]] <- trajdat
  }
  ## Extract and bind data
  newdata <- traj_list %>% list.rbind() %>% as.data.frame() %>% 'colnames<-'(c(paste0("V",seq(1,8,1))))
  updated_cluslist <- rbind(cluslist,newdata)
  ## Update #traj/cluster (V2).
  updated_cluslist <- updated_cluslist %>%
    group_by(V1) %>%
    mutate(V2 = n()) %>%
    ungroup()
  updated_cluslist
}

